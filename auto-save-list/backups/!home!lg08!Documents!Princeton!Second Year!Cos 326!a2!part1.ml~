(*************)
(* PROBLEM 1 *)
(*************)

(* For each part of problem 1, explain in the given string why the code
   will not typecheck, then follow the instructions for that part to
   change the code so that it typechecks while keeping the same values
   as intended by the erroneous code. Once you have done so, uncomment
   the fixed expression for submission.
*)

(* Problem 1a - Give your explanation in exp1a and then fix the
   right-hand-side of the assignment to match the listed type. 
   (Do not change the left-hand-side.)
*)


let exp1a : string = "Basically, this declaration just isn't returning a list 
of integers. One way to fix this is just by changing the commas to semicolons."
let prob1a : int list = [1; 2; 3]

(* Problem 1b - Give your explanation in exp1b and then fix the type
   of variable prob1b to match the type of the expression on the
   right-hand-side of the assignment. (Do not change the
   right-hand-side.)
 *)

let exp1b : string = "The declaration is asking for a pair, one of type 
'string' and the other of type 'int list'. However, the declaration is actually 
returning a list of pairs"
(* let prob1b : string * int list = ("COS", [441]) *)

(* Problem 1c - Give your explanation in exp1c and then fix the
   right-hand-side of the expression to match the variable prob1c's
   listed type. 
   (Do not change the left-hand-side.)  
*)

let exp1c : string = "Basically, this is trying to append a float list as
a float to another float list. Instead, we need to append floats onto an
 existing float list"
let prob1c : float list = 2.0 :: 3.0 :: [4.0; 5.0]

(*************)
(* PROBLEM 2 *)
(*************)

(* Fill in expressions to satisfy the following types: 
 *
 * NOTE: for option, list, and function types, you must 
 * provide a nontrivial answer. For a list that means a 
 * non-empty one, for an option type that means a Some 
 * construction, and for a function, that means using 
 * its arguments to generate the return value.
 * example problems:
 *   let x : int option = ???
 *   let y : int list = ???
 *   let f (x: int) (y: int) : int = ???
 * incorrect answers:
 *   let x : int option = None
 *   let y : int list = []
 *   let f (x: int) (y: int) : int = 7
 * possible correct answers:
 *   let x : int option = Some 1
 *   let y : int list = [1]
 *   let y : int list = [1; 2]
 *   let y : int list = 1 :: [2]
 *   let f (x: int) (y: int) : int = x + y
 *   let f (x: int) (y: int) : int = 
 *         String.length  ((string_of_int x) ^ (string_of_int y))
 *)

(*>* Problem 2a *>*)
 
let prob2a : (float * (string * int) option list) list =
  (4.0, Some ("string", 3) :: []) :: []

(*>* Problem 2b *>*)
(* a student is a (name, age option) pair *)

type student = string * int option

let prob2b : (student list option * int) list =
  (Some [("George", Some 14)], 3) :: []

(*>* Problem 2c *>*)

let prob2c : (int * int -> int) * (float -> float -> unit) * bool  =
  ((fun (x:int * int) -> match x with (y, z) -> y + z),
   (fun (a:float) (b:float) -> print_float (a +. b)), (true))

(*>* Problem 2d *>*)
(* Fill in a valid function call to foo to make prob2d typecheck *)

let prob2d =
  let rec foo bar =
    match bar with
    | (a, (b, c)) :: xs -> if a then (b + c + (foo xs)) else foo xs
    | _ -> 0
  in
  foo [(true, (2, 3))]




(*************)
(* PROBLEM 3 *)
(*************)

(* Consider the following terribly written function: *)

let rec zardoz f ls acc =
  if (((List.length (ls@[])) = 1) = true) then (f (List.hd(ls)) (acc))
  else if (((List.length ls) = 0) = true) then acc
  else
    let hd = List.hd(ls) in
        let tl = List.tl(ls) in
      let ans = f (hd) (acc) in
    let ans = zardoz f tl ans in
        ans
  
(* Rewrite the code above so that it does the same thing
 * but style-wise is far superior.  
 * Be sure to provide types for the function's arguments and to 
 * call itself (not the original zardoz) recursively as needed.
 * You may want to write some assert statements
 * to check that your function is doing the same thing as zardoz.  
 * Use the COS 326 style guide. *)

(* this function does the same thing as zardoz! *)
let rec myzardoz (f:'a->'b->'b) (ls:'a list) (acc:'b) : 'b =
  match ls with
  | [] -> acc
  | hd :: tl ->
     (match tl with
      | [] -> f hd acc
      | hd2 :: tl2 ->
         myzardoz f tl (f hd acc)
     )






(*************)
(* PROBLEM 4 *)
(*************)

(***************************************)
(* Conway's Lost Cosmological Theorem! *)
(***************************************)

(* 

If l is any list of integers, the look-and-say list of s is obtained by 
reading off adjacent groups of identical elements in s. For example, the 
look-and-say list of

l = [2; 2; 2]

is

[3; 2]

because l is exactly "three twos." Similarly, the look-and-say sequence of

l = [1; 2; 2]

is

[1; 1; 2; 2]

because l is exactly "one ones, then two twos."

You will now define a function look_and_say that computes the 
look-and-say sequence of its argument. look_and_say of an empty 
list is the empty list. 

For full credit your solution should be a linear time solution.

CULTURAL ASIDE:

The title of this problem comes from a theorem about the sequence generated 
by repeated applications of the "look and say" operation. As look and say 
has type int list -> int list, the function can be applied to its own result. 
For example, if we start with the list of length one consisting of just the 
number 1, we get the following first 6 elements of the sequence:

[1]
[1,1]
[2,1]
[1,2,1,1]
[1,1,1,2,2,1]
[3,1,2,2,1,1]

Conway's theorem states that any element of this sequence will "decay" 
(by repeated applications of look and say) into a "compound" made up of 
combinations of "primitive elements" (there are 92 of them, plus 2 
infinite families) in 24 steps. If you are interested in this sequence, 
you may wish to consult [Conway(1987)] or other papers about the 
"look and say" operation.

====== 

Progamming practice aside related to the "look and say" problem. You
may find this useful for constructing your solution to "look and say",
or you may not. 

Another interesting list problem is determining "runs"
in a list: maximal length sublists with all equal elements. For
example,

[1; 1; 1] and [5]

are both runs of the list

[1; 1; 1; 5; 2]

but

[1; 1] and [5; 2] and [1; 2]

are not: 

[1; 1] is not maximal
[5; 2] has unequal elements
[1; 2] is not a sublist.

*)

(* this function prints out a new list of ints according to how an original \
list looks
 *)
let look_and_say (xs: int list) : int list =
  (* just reverses the order of a list *)
  let rec rev_list (list: 'a list) (return_list: 'a list) : 'a list =
    match list with
    | [] -> return_list
    | hd :: tl ->
       rev_list tl (hd :: return_list)
  in
    (* recursive function to generate a list of tuples *)
  let rec loop (count:int) (last_num:int) (list: int list) (new_list: int list)
          : int list =
    match list with
    (* if empty, return the list we've created *)
    | [] ->
       rev_list (last_num :: count :: new_list) []
    | hd :: tl ->
       (* if it's the same number, just continue *)
       if hd == last_num then
         loop (count + 1) last_num tl new_list
       (* otherwise, add the count and the last number to the list *)
       else
         (* adds the count and last number to the new_list and resets the count 
and last num
 *)
         loop 1 hd tl (last_num :: count :: new_list)
  in
  match xs with
  | [] -> []
  | hd :: tl ->
     loop 1 hd tl []





(*************)
(* PROBLEM 5 *)
(*************)
          
(* Write a function that flattens a list of lists in to a single
 * list with all of the elements in the same order they appeared in 
 * the original list of lists. eg:
 *
 * flatten [[1;2;3]; []; [4]; [5;6]] = [1;2;3;4;5;6] 
 * flatten [[]; ['e';'d']; ['a';'b';'c']] = ['e';'d';'a';'b';'c'] 
 *)

(* flattens a list of lists into a single list *)
let rec flatten (xss:'a list list) : 'a list =
  (* just reverses the given list *)
  let rev (list: 'a list) : 'a list =
    let rec rev_list (list: 'a list) (return_list: 'a list) : 'a list =
      match list with
      | [] -> return_list
      | hd :: tl ->
         rev_list tl (hd :: return_list)
    in
    rev_list list []
  in  
  (* just concatenates two lists like @ *)
  let concat (list1: 'a list) (list2: 'a list) : 'a list =
  (* reverses the original list *)
  let new_list1 = rev list1 in
  (* adds each item to the second list *)
  let rec loop (initial_list: 'a list) (second_list: 'a list) : 'a list =
    match initial_list with
    | [] -> second_list
    | hd :: tl ->
       loop tl (hd :: second_list)
  in
  loop new_list1 list2
  in
  (* takes items from a list and puts them in another *)
  let rec unpack (list:'a list) (return_list: 'a list) : 'a list =
    match list with
    | [] -> return_list
    | hd :: tl ->
       unpack tl (hd :: return_list)
  in
  (* passes all lists into unpack *)
  let rec visit_all_lists (list: 'a list list) (return_list: 'a list)=
    match list with
    | [] -> rev return_list
    | hd :: tl ->
       visit_all_lists tl (concat (unpack hd []) return_list)
  in
  visit_all_lists xss []


       


  
(*************************************)
(* PROBLEM 6 -- Warning: Challenging!*)
(*************************************)

(* Return the list of all permutations of the input list. eg: 
   perm [1;2;3] = [[1;2;3]; [1;3;2]; [2;1;3]; [2;3;1]; [3;1;2]; [3;2;1]] 
   The ordering of the permutations does not matter in your solution.
   We will accept either [[]] or [] as the result for perm [].
   NB: test this on small inputs - perm is ~n! which is approximately ~n^n.
 *)


let perm (items:'a list) : 'a list list =
  (* just returns the length of the list *)
  let length (list: 'a list) : int =
    let rec loop (list2: 'a list) (count: int) : int =
      match list2 with
      | [] -> count
      | hd :: tl ->
         loop tl (count + 1)
    in
    loop list 0
  in
  (* concatenates two lists just like @ from list module *)
  let concat list1 list2  =
    let rev list  =
      let rec rev_list list return_list  =
        match list with
        | [] -> return_list
        | hd :: tl ->
           rev_list tl (hd :: return_list)
      in
      rev_list list []
    in
    let new_list1 = rev list1 in
    let rec loop initial_list second_list  =
      match initial_list with
      | [] -> second_list
      | hd :: tl ->
         loop tl (hd :: second_list)
    in
    loop new_list1 list2
  in
  (* this function inserts an item into a given list at the given point or at 
the end if the point is longer than the lists length *)
    let rec insert (item: 'a) (initial_list: 'a list) (n: 'int)
              (final_list: 'a list) : 'a list =
    match initial_list with
    | [] -> concat final_list [item]
    | hd :: tl ->
       (* if we reach the spot, insert the item and return the new list *)
       if n == 0 then
         concat final_list (item :: hd :: tl)
       else
         insert item tl (n-1) (concat final_list [hd])
  in
  (* just a prettier insert function without extra args *)
  let pretty_insert (item: 'a) (list: 'a list) (n: int) =
    insert item list n []
  in
  (* returns a list of lists with an item inserted at different indexes of the 
original list
 *)
  let rec add_a_bunch (itemy: 'a) (listy: 'a list) (list_to_return:'a list list)
            (count: int) : 'a list list =
    if count == (length listy + 1) then
      list_to_return
    else
      add_a_bunch itemy listy (
          (pretty_insert itemy listy count) :: list_to_return) (count + 1)
  in
  (* just makes add_a_bunch a lil prettier *)
  let pretty_add_a_bunch (item: 'a) (list: 'a list) : 'a list list =
    add_a_bunch item list [] 0
  in
  (* just takes a list of lists as an argument and returns the result of 
pretty_add_a_bunch on each *)
  let rec insert_list_of_list (list: 'a list list) (item: 'a)
            (return_list: 'a list list) : 'a list list =
    match list, return_list with
    | [], head:: tail ->
       return_list
    |[], [] -> pretty_add_a_bunch item []
    | hd :: tl, _ ->
       insert_list_of_list tl item (concat (pretty_add_a_bunch item hd)
                                      return_list)
  in
  (* finally just takes in a list of items and uses each as the item in 
insert_list_of_list
 *)
  let rec final_wrapper (original_list: 'a list) (list_of_list: 'a list list) =
    match original_list with
    | [] -> list_of_list
    | hd :: tl ->
       final_wrapper tl (insert_list_of_list list_of_list hd [])
  in
  final_wrapper items []
          



(* Optional, ungraded, but easy:

Define the factorial function, then try this:


let testperm al =
  assert (List.length (perm al) = fac(List.length al))

let _ = testperm [1;2;3]   (* etc *)

*)
  
 
