(*********************)
(* Dynamic ML Syntax *)
(*********************)

type variable = string 

(* Equality and Inequality for variables *)
let var_eq x y = (String.compare x y = 0)
let var_neq x y = not (String.compare x y = 0)

type constant = Int of int | Bool of bool 

type operator = Plus | Minus | Times | Div | Less | LessEq 

type exp = 

  (* Basic *)
  | Var of variable   
  | Constant of constant
  | Op of exp * operator * exp
  (* If (conditional, consequent, alternative) *)
  | If of exp * exp * exp
  (* Let (v, e1, e2) is a let binding with the form let v = e1 in e2 *)
  | Let of variable * exp * exp

  (* Pairs *)
  | Pair of exp * exp
  | Fst of exp
  | Snd of exp

  (* Lists *)
  | EmptyList
  (* Note 1: this permits type-heterogeneity, unlike OCaml, e.g.:
     Cons (Constant (Int 1), Cons (Constant (Bool true), EmptyList)) 
    
     Note 2: this also doesn't enforce that a list should end in a 
     Cons with EmptyList as the second argument, but we will only 
     ever use well-defined lists of this structure.
  *)
  | Cons of exp * exp
  (*   Match (e1, e2, hd, tl, e3) is a match statement with the form:
   match e1 with 
   | [] -> e2 
   | hd::tl -> e3 
  *)                  
  | Match of exp * exp * variable * variable * exp  

  (* Functions *)
  (* Rec (f, x, b) is the definition of a possibly-recursive function
     The function is named f and x is the name of the parameter. b is 
     the body of the expression, and may contain f and/or x.
  *)
  | Rec of variable * variable * exp
  (*
   Closure (e, f, x, b) is a closure of a possibly-recursive function.
   The closure environment is e.  f, x, and b are the same as in the 
   definition of the function.
  *)
  | Closure of env * variable * variable * exp
  (* App (f, x) is a function call of closure f with argument x *)
  | App of exp * exp

and env = (variable * exp) list

(*****************************)
(* Manipulating environments *)
(*****************************)
 
(* empty environment *)
let empty_env : env = []

(* lookup_env env x == Some v 
 *   where (x,v) is the most recently added pair (x,v) containing x
 * lookup_env env x == None 
 *   if x does not appear in env *)
let rec lookup_env (env:env) (x:variable) : exp option =
  match env with
  |[] -> None
  | hd :: tl ->
     (match hd with
      | (var, expr) ->
         (if (var_eq var x) then
            Some expr
          else
            lookup_env tl x
         )
     )

(* update env x v returns a new env containing the pair (x,v) 
 * The exact operation (replacing, overriding, etc.) is up to 
 * you, but clearly your other functions (notably lookup_env) 
 * must know the semantics of update_env
*)
let update_env (env:env) (x:variable) (v:exp) : env = 
  let rec run_through_env (environment:env) (var:variable) (expr: exp) : env =
    match environment with
    | [] ->
       (var, expr) :: []
    | hd :: tl ->
       (match hd with
        | (variable, expression) ->
           if (var_eq variable var) then
             (var, expr) :: tl
           else
             hd :: (run_through_env tl var expr)
       )
  in
  run_through_env env x v

(* let testenv : (variable * exp) list = [("z", one); ("x", two); ("y", four)] *)

(* let testy = update_env testenv "y" three *)
                  (* end of syntex ----------------------------------------------- *)


let string_of_const c = 
  match c with 
    | Int i -> string_of_int i
    | Bool b -> string_of_bool b


let string_of_op op = 
  match op with 
    | Plus -> "+" 
    | Minus -> "-" 
    | Times -> "*" 
    | Div -> "/" 
    | Less -> "<" 
    | LessEq -> "<=" 

let max_prec = 10

let precedence e = 
  match e with 
    | Constant _ -> 0
    | Var _ -> 0
    | Op (_,Plus,_) -> 5
    | Op (_,Minus,_) -> 5
    | Op (_,Times,_) -> 3
    | Op (_,Div,_) -> 3
    | Op (_,Less,_) -> 7
    | Op (_,LessEq,_) -> 7
    | Let _ -> max_prec
    | If _ -> max_prec

    | Pair _ -> 0
    | Fst _ -> 2
    | Snd _ -> 2

    | EmptyList -> 0
    | Cons _ -> 8
    | Match _ -> max_prec

    | Rec _ -> max_prec
    | Closure _ -> max_prec
    | App _ ->  2

let rec env2string env =
  let elem2string x v = x ^ "=" ^ exp2string max_prec v in
  let rec aux env =
    match env with
	[] -> ""
      | [(x,v)] -> elem2string x v
      | (x,v)::rest -> elem2string x v ^ ";" ^ aux rest 
  in
  "[" ^ aux env ^ "]"

and exp2string prec e = 
  let p = precedence e in 
  let s = 
    match e with 
      | Constant c -> string_of_const c
      | Op (e1,op,e2) -> 
          (exp2string p e1) ^ " "^(string_of_op op)^" "^(exp2string prec e2)
      | Var x -> x
      | If (e1, e2, e3) -> 
        "if " ^ (exp2string max_prec e1) ^ 
        " then " ^ (exp2string max_prec e2) ^ 
        " else " ^ (exp2string p e3)
      | Let (x,e1,e2) -> "let "^x^" = "^(exp2string max_prec e1)^" in "^
          (exp2string prec e2)

      | Pair (e1, e2) -> 
	  "(" ^ (exp2string max_prec e1) ^ "," ^ (exp2string max_prec e2)  ^ ")"
      | Fst e1 ->  "fst " ^ (exp2string p e1)
      | Snd e1 ->  "snd " ^ (exp2string p e1)

      | EmptyList -> "[]"
      | Cons (e1,e2) -> (exp2string p e1) ^ "::" ^ (exp2string prec e2) 
      | Match (e1,e2,hd,tl,e3) -> 
	  "match " ^ (exp2string max_prec e1) ^ 
	    " with [] -> " ^ (exp2string max_prec e2) ^ 
            " | " ^ hd ^ "::" ^ tl ^ " -> " ^ (exp2string p e3)

      | Rec (f,x,body) -> "rec "^f^" "^x^" = "^(exp2string max_prec body)
      | Closure (env,f,x,body) -> 
	  "closure "^env2string env^" "^f^" "^x^" = "^(exp2string max_prec body)
      | App (e1,e2) -> (exp2string p e1)^" "^(exp2string p e2)

  in 
    if p > prec then "(" ^ s ^ ")" else s

let string_of_exp e = exp2string max_prec e 
let string_of_env env = env2string env


                                   (* end of printing ------------------------------- *)


exception UnboundVariable of variable 
exception BadApplication of exp 
exception BadIf of exp 
exception BadMatch of exp 
exception BadOp of exp * operator * exp 
exception BadPair of exp 

(* evaluation of primitive operators *)

let apply_op (v1:exp) (op:operator) (v2:exp) : exp = 
     match v1, op, v2 with 
       | Constant (Int i), Plus, Constant (Int j) -> 
         Constant (Int (i+j))
       | Constant (Int i), Minus, Constant (Int j) -> 
         Constant (Int (i-j))
       | Constant (Int i), Times, Constant (Int j) -> 
         Constant (Int (i*j))
       | Constant (Int i), Div, Constant (Int j) -> 
         Constant (Int (i/j))
       | Constant (Int i), Less, Constant (Int j) -> 
         Constant (Bool (i<j))
       | Constant (Int i), LessEq, Constant (Int j) -> 
         Constant (Bool (i<=j))
       | _, _, _ -> raise (BadOp (v1,op,v2))

                          (*  end of util ------------------------------------------- *)



let rec is_value (e:exp) : bool = 
  match e with
      Constant _ -> true  
    | Pair (e1, e2) -> is_value e1 && is_value e2
    | EmptyList -> true
    | Cons (e1, e2) -> is_value e1 && is_value e2
    | Closure _ -> true
    | _ -> false

(* evaluation; use eval_loop to recursively evaluate subexpressions *)
let eval_body (env:env) (eval_loop:env -> exp -> exp) (e:exp) : exp = 
  match e with
    | Var x -> 
      (match lookup_env env x with 
  	  None -> raise (UnboundVariable x)
	| Some v -> v
      )
    | Constant constant ->
       Constant constant
    | Op (exp1, operator, exp2) ->
       apply_op (eval_loop env exp1) operator (eval_loop env exp2)
    | If (conditional, consequent, alternative) ->
       (match conditional with
        | Op (exp1, operator, exp2) ->
           (match operator with
            | Less | LessEq ->
               let boolean = apply_op (eval_loop env exp1) operator (eval_loop env exp2) in
               (match boolean with
                | Constant booly ->
                   (match booly with
                    | Bool yes ->
                       if yes then
                         eval_loop env consequent
                       else
                         eval_loop env alternative
                    | _ -> raise (BadOp (exp1, operator, exp2))
                   )
                | _ -> raise (BadOp (exp1, operator, exp2))
               )
            | _ -> raise (BadOp (exp1, operator, exp2))
           )
        | Constant constant ->
           (match constant with
            | Int int -> raise (BadIf (conditional))
            | Bool boolean ->
               if boolean then
                 consequent
               else
                 alternative
           )
        | _ -> raise (BadIf (conditional))
       )
    | Let (variable, expr1, expr2) ->
       let new_env = update_env env variable expr1 in
       eval_loop new_env expr2
    | Pair (expr1, expr2) ->
       Pair (expr1, expr2)
    | Fst pair ->
       (match pair with
        |Pair (expr1, expr2) ->
          eval_loop env expr1
        | _ -> raise (BadPair (pair))
       )
    | Snd pair ->
       (match pair with
        | Pair (expr1, expr2) ->
           eval_loop env expr2
        | _ -> raise (BadPair (pair))
       )
    | EmptyList ->
       EmptyList
    | Cons (exp1, exp2) ->
       Cons (exp1, exp2)
    | Match (exp1, exp2, var1, var2, exp3) ->
       (match exp1 with
        | EmptyList ->
           eval_loop env exp2
        | Cons (e1, e2) ->
           let new_env = update_env env var1 e1 in
           let newer_env = update_env new_env var2 e2 in
           eval_loop newer_env exp3
        | _ ->
           raise (BadMatch (exp1))
       )
    | Rec (function_name, parameter, body) ->
       (* puts the function name as a variable into the environment *)
       let new_env = update_env env function_name body in
       Closure (new_env, function_name, parameter, body)
    | Closure (environment, function_name, parameter, body) ->
       Closure (environment, function_name, parameter, body)
    | App (f, x) ->
       (* let closure = eval_loop env f in *)
       (match f with
       | Closure (environment, function_name, parameter, body) ->
          let new_env = update_env environment parameter x in
          eval_loop new_env body
       | Rec (function_name, parameter, body) ->
          let closure = eval_loop env (Rec (function_name, parameter, body)) in
          (match closure with
           | Closure (environment, function_name, parameter, body) ->
              let new_env = update_env environment parameter x in
              eval_loop new_env body
           | _ ->
              raise (BadApplication (f))
          )
       |Var variable ->
         let new_body = lookup_env env variable in
         (match new_body with
         | None -> raise (UnboundVariable variable)
         | Some thing ->
            eval_loop env thing)
        
         (* let closure = lookup_env env variable in
          * (match closure with
          *  | None -> raise (UnboundVariable variable)
          *  | Some exp -> 
          *     eval_loop env (App (exp, x))
          * ) *)
       | _ ->
          raise (BadApplication (f)) (* this the one *)
       )

         (* start of all the testing stuff ------------------------------- *)
let zero = Constant (Int 0) 
let one = Constant (Int 1) 
let two = Constant (Int 2) 
let three = Constant (Int 3) 
let four = Constant (Int 4)

let eval e =
  let rec loop env e = eval_body env loop e in
  loop empty_env e

(* rec fact n = if n < 1 then 1 else n * fact (n - 1) *)
let fact = 
  Rec ("fact", "n", 
       If (Op (Var "n", Less, one),
           one,
           Op (Var "n", Times, 
               App (Var "fact", 
                    Op (Var "n", Minus, one))
    )))

let rectest =
  Rec ("rectest", "n",
       If (Op (Var "n", Less, three),
           one,
           App (Var "rectest", Op (Var "n", Minus, one))
         )
    )

let t = Rec ("t", "n",
             Op (Var "n", Plus, three)
          )

(* fact 4 *)
let fact4 = App (t, four)

let testy = eval fact4

(* let blah = [1;2;3;4] *)
