(* Box office analysis *)

(* Contents:
    -- the movie type
    -- the studio_gross type
    -- functions for querying and transforming lists of movies
 *)

(* a movie is a tuple of (title, studio, gross in millions, year) *)
type movie = string * string * float * int

(* a studio_gross is a pair of (studio, gross in millions) *)
type studio_gross = string * float

(* call bad_argument if your function receives a bad argument *)
(* do not change this exception or function                   *)
exception Bad_arg of string
let bad_arg (s:string) = raise (Bad_arg s)

(* a useful debugging routine *)
let debug s = print_string s; flush_all()

(* *** DO NOT CHANGE DEFINITIONS ABOVE THIS LINE! *** *)

(* you may add "rec" after any of the let declarations below that you
 * wish if you find doing so useful. *)


(* find the average gross of the movies in the list                  *)
(* return 0.0 if the list is empty                                   *)
(* hint: you may need to use functions float_of_int and int_of_float *)
(* hint: if you don't know what those functions do,                  *)
(*       type them in to ocaml toplevel                              *)
(* hint: recall the difference between +. and + also 0. and 0        *)
let average (movies : movie list) : float =
  (* just returns the length of the list *)
  let length (list: 'a list) : int =
    let rec loop (list2: 'a list) (count: int) : int =
      match list2 with
      | [] -> count
      | hd :: tl ->
         loop tl (count + 1)
    in
    loop list 0
  in
  (* failwith "average unimplemented" *)
  match movies with
  | [] -> 0.0
  | hd :: tl ->
     (* adds up all the gross' from the list *)
     let rec add_up_gross (movies: movie list) (sum: float) : float =
       match movies with
       | [] -> sum
       | hd :: tl ->
          match hd with
          | (title, studio, gross, year) ->
             add_up_gross tl (sum +. gross)
     in
     (add_up_gross movies 0.0) /. (float_of_int (length movies))


(* return a list containing only the movies from the given decade *)
(* call bad_arg if n is not 20, ..., 90, 00, 10.                  *)
(* Treat 0 as 00 (this is unavoidable as 00 is not represented    *)
(*   differently from 0).                                         *)
(* Note: movies from any years outside the range 1920-2019 will   *)
(* always be discarded but should not raise an error condition    *)
let decade (n:int) (ms:movie list) : movie list =  
  (* failwith "decade unimplemented" *)
  match ms with
  | [] -> []
  | hd :: tl ->
     (* makes a list of all the movies in the decade *)
     let rec accumulate_movies (ms: movie list) (return_list: movie list)
               (n: int) : movie list =
       match ms with
       | [] -> return_list
       | hd :: tl ->
          match hd with
          | (title, studio, gross, year) ->
             if year >= n && year <= (n + 10) then
               accumulate_movies tl (hd :: return_list) n
             else
               accumulate_movies tl (return_list) n
     in
     let determine_year (n: int) : int = 
       match n with
       | 20 -> 1920
       | 30 -> 1930
       | 40 -> 1940
       | 50 -> 1950
       | 60 -> 1960
       | 70 -> 1970
       | 80 -> 1980
       | 90 -> 1990
       | 0 -> 2000
       | 10 -> 2010
       | _ -> bad_arg "decade unimplemented"
     in
     accumulate_movies ms [] (determine_year n)




(* return the first n items from the list *)
(* if there are fewer than n items, return all of them *)
(* call bad_arg if n is negative *)
let take (n:int) (l:'a list)  : 'a list =
  (* just reverses the items in a list *)
  let rev (list: 'a list) : 'a list =
    let rec rev_list (list: 'a list) (return_list: 'a list) : 'a list =
      match list with
      | [] -> return_list
      | hd :: tl ->
         rev_list tl (hd :: return_list)
    in
    rev_list list []
  in
  (* failwith "take unimplemented" *)
  if n == 0 then
    []
  else
    if n < 0 then
      bad_arg "take unimplemented"
    else
      (* gathers all the items into a list *)
      let rec gather_items (n:int) (l: 'a list) (return_list: 'a list)
              : 'a list =
        match l with
        | [] ->
           rev return_list
        | hd :: tl ->
           if n == 1 then
             rev (hd :: return_list)
           else
             gather_items (n - 1) tl (hd :: return_list)
      in
      gather_items n l []

(* return everything but the first n items from the list *)
(* if there are fewer than n items, return the empty list *)
(* call bad_arg if n is negative *)
let rec drop (n:int) (l:'a list)  : 'a list =
  if n < 0 then
    bad_arg "drop unimplemented"
  else
    (* failwith "drop unimplemented" *)
    (* returns an empty list, or the tail if n = 0 *)
    match l with
    | [] -> []
    | hd :: tl ->
       if n == 0 then
         hd :: tl
       else
         drop (n-1) (tl)


(* return a list [x1; x2; ...; xn] with the same elements as the input l
   and where:
     leq xn xn-1
     ...
     leq x3 x2
     leq x2 x1
     are all true
 *)
(* hint: define an auxiliary function "select" *)
type 'a less = 'a -> 'a -> bool
let selection_sort (leq:'a less) (l:'a list) : 'a list =
  (* failwith "selection_sort unimplemented" *)
  (* returns an item from the list according to leq *)
  let rec delete_and_reformat (list: 'a list) (item: 'a)
            (beginning_list: 'a list) : 'a list =
    (* just concatenates two lists like @ *)
    let concat (list1: 'a list) (list2: 'a list) : 'a list =
      let rev (list: 'a list) : 'a list =
        let rec rev_list (list: 'a list) (return_list: 'a list) : 'a list =
          match list with
          | [] -> return_list
          | hd :: tl ->
             rev_list tl (hd :: return_list)
        in
        rev_list list []
      in
      let new_list1 = rev list1 in
      let rec loop (initial_list: 'a list) (second_list: 'a list) : 'a list =
        match initial_list with
        | [] -> second_list
        | hd :: tl ->
           loop tl (hd :: second_list)
      in
      loop new_list1 list2
    in
    match list with
    | [] ->  beginning_list
    | hd :: tl ->
       if hd == item then
         concat beginning_list tl
       else
         delete_and_reformat tl item (hd :: beginning_list)
  in
  (* selects the best item from the list and returns it *)
  let rec select (list: 'a list) (best: 'a) (count:int) : 'a =
    match list with
    | [] ->
       best
    | hd :: tl ->
       (* if it's the first iteration, just put the head as the best *)
       if count == 0 then
         select tl hd (count + 1)
       else
         (* otherwise, check to see if the head is more than best *)
         if leq hd best then
           select tl hd (count+ 1)
         else
           select tl best (count + 1)
  in
  (* returns the sorted list *)
  let rec return_sorted (initial_list: 'a list) (return_list: 'a list)
          : 'a list =
    match initial_list with
    | [] ->
       return_list
    | hd :: tl ->
       (* gets the best number *)
       let best = select initial_list hd 0 in
       (* takes the best out of the initial list *)
       let new_list = delete_and_reformat initial_list best [] in
       (* recursively calls iteself *)
       return_sorted new_list (best :: return_list)
  in
  return_sorted l []


(* ASIDE:  Why does this assignment ask you to implement selection sort?
   Insertion sort is almost always preferable to selection sort,
   if you have to implement a quadratic-time sorting algorithm.
   Insertion sort is faster, it's simpler to implement, and it's
   easier to reason about.  For smallish inputs (less than 5 or 8),
   insertion sort is typically faster than quicksort or any
   other NlogN sorting algorithm.  So, why do we ask you to implement
   selection sort?  Answer: we already showed you insertion sort
   in the lecture notes.

   ASIDE 2: But at least selection sort is better than bubble sort.
   Even Barack Obama knows that. https://www.youtube.com/watch?v=k4RRi_ntQc8
 *)

(* return list of movies sorted by gross (largest gross first) *)
let sort_by_gross (movies : movie list) : movie list = 
  (* failwith "sort_by_gross unimplemented" *)
  (* describes whether movie1's grossis greater or not *)
  let greater_gross (movie1: movie) (movie2: movie) : bool =
    match (movie1, movie2) with
      ((title1, studio1, gross1, year1), (title2, studio2, gross2, year2)) ->
      if gross1 < gross2 then
        true
      else
        false
  in
  selection_sort greater_gross movies


(* return list of movies sorted by year produced (largest year first) *)
let sort_by_year (movies : movie list) : movie list = 
  (* failwith "sort_by_year unimplemented" *)
  (* describes whether movie1's year is greater or not *)
  let greater_year (movie1: movie) (movie2: movie) : bool =
    match (movie1, movie2) with
      ((title1, studio1, gross1, year1), (title2, studio2, gross2, year2)) ->
      if year1 < year2 then
        true
      else
        false
  in
  selection_sort greater_year movies

(* sort list of (studio, gross in millions) by gross in millions 
 * with the largest gross first *)
let sort_by_studio (studio_grosses : studio_gross list) : studio_gross list = 
  (* failwith "sort_by_studio unimplemented" *)
  (* describes whether a studio's gross is greater or not *)
  let greater_gross (studio1: studio_gross) (studio2: studio_gross) : bool =
    match (studio1, studio2) with
      ((studio1, gross1), (studio2, gross2)) ->
      if gross1 < gross2 then
        true
      else
        false
  in
  selection_sort greater_gross studio_grosses

(* given list of movies,
 * return list of pairs (studio_name, total gross revenue for that studio)  *)
let by_studio (movies:movie list) : studio_gross list =
  (* just concatenates two lists like @ *)
  let concat (list1: 'a list) (list2: 'a list) : 'a list =
      let rev (list: 'a list) : 'a list =
        let rec rev_list (list: 'a list) (return_list: 'a list) : 'a list =
          match list with
          | [] -> return_list
          | hd :: tl ->
             rev_list tl (hd :: return_list)
        in
        rev_list list []
      in
      let new_list1 = rev list1 in
      let rec loop (initial_list: 'a list) (second_list: 'a list) : 'a list =
        match initial_list with
        | [] -> second_list
        | hd :: tl ->
           loop tl (hd :: second_list)
      in
      loop new_list1 list2
    in
(* 
just checks to see if we've already found a movie with that studio and
returns it as well as a list without that studio_gross in it
*)
    let rec check_for_studio (movie: movie) (list: studio_gross list) 
              (beginning_list: studio_gross list) : bool * (studio_gross) * studio_gross list =
      match list with
      | [] ->
         (false, ("arbitrary", 0.0), beginning_list)
      | hd :: tl ->
         match hd, movie with
         | (studio, gross), (title2, studio2, gross2, year2) ->
            if studio = studio2 then
              (true, hd, concat beginning_list tl)
            else
              check_for_studio movie tl (hd :: beginning_list)
    in
    (* failwith "by_studio unimplemented" *)
    (* makes the list of studio_gross's *)
  let rec make_list (movies: movie list) (return_list: studio_gross list)
          :studio_gross list =
    match movies with
    | [] -> return_list
    | hd :: tl ->
       match hd with
       | (title, studio, gross, year) ->
          let (repeat_studio, old_studio, new_list) = check_for_studio hd return_list [] in
          if repeat_studio then
            let (studio_name, old_gross) = old_studio in
            make_list tl ((studio_name, (old_gross +. gross)) :: new_list)
          else
            make_list tl ((studio, gross) :: return_list)
  in
  make_list movies []


(***********)
(* Testing *)
(***********)

(* Augment the testing infrastructure below as you see fit *)

(* Test Data *)

let data1 : movie list = [
    ("The Lord of the Rings: The Return of the King","NL",377.85,2003)
  ]

let data2 : movie list = [
    ("The Lord of the Rings: The Return of the King","NL",377.85,2003);
    ("The Hunger Games","LGF",374.32,2012)
  ]

let data3 : movie list = [
    ("Harry Potter and the Sorcerer's Stone","WB",317.57555,2001);
    ("Star Wars: Episode II - Attack of the Clones","Fox",310.67674,2002);
    ("Return of the Jedi", "Fox", 309.306177, 1983)
  ]

let data4 : movie list = [
    ("The Lord of the Rings: The Return of the King","NL",377.85,2003);
    ("The Hunger Games","LGF",374.32,2012);
    ("The Dark Knight","WB",533.34,2008);
    ("Harry Potter and the Deathly Hallows Part 2","WB",381.01,2011)
  ]

(* Assertion Testing *)

(* Uncomment the following when you are ready to test your take routine *)

let _ = assert(take 0 data4 = [])
let _ = assert(take 1 data1 = data1)
let _ = assert(take 2 data4 = data2)
let _ = assert(take 5 data2 = data2)
let _ = assert(take 2 data2 = data2)

              (* Additional Testing Infrastructure *)

              let stests : (unit -> movie list) list = [
                (fun () -> sort_by_gross data1);
                (fun () -> sort_by_gross data2);
                (fun () -> sort_by_gross data3);
                (fun () -> sort_by_gross data4)
              ]
              
              let check (i:int) (tests:(unit -> 'a) list) : 'a =
                if i < List.length tests && i >= 0 then
                  List.nth tests i ()
                else
                  failwith ("bad test" ^ string_of_int i)



