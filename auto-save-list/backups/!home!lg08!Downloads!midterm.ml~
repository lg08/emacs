(* RULES FOR THIS EXAM:
 1. You may use written sources if they are directly linked from the
    course web site.  You may use Real World OCaml. You may use
    the OCaml manual at https://caml.inria.fr/pub/docs/manual-ocaml/
    You may use YOUR solutions to the homeworks, but not other people's.
    If you paste anything in from one of these sources (even if you modify it),
    cite your source.

 2. Avoid any other sources -- so in particular, no searches on
    Google or any other search engine.

 3. You may not ask any human for help, EXCEPT if you have logistical
    problems obtaining or uploading the exam;  in which case, post a
    PRIVATE message on Ed.  We can't monitor Ed every single minute, though.

 4. Do not post any PUBLIC messages on Ed from October 15 through October 17.

 5. Request the exam by going to the Tigerfile link and,
    (without having uploaded anything), click the "Check" button.
    Then the exam will be e-mailed to your princeton.edu e-mail.

 6. You have TWO HOURS from the time you receive the exam to when you
    must upload it to Tigerfile.  We will not shut off the upload capability,
    but we will log the time.   Working more than 2 hours on the exam is a
    violation of University rules.

 7. If it takes more than 5 minutes from the time you request the exam
    to when you receive it in e-mail, IMMEDIATELY forward the e-mail
    to joomy@cs.princeton.edu as a record of when you did receive it,
    with "Subject: Received exam late".  Don't write a lengthy
    explanation, we'll know what it's about!  Then start working on
    the exam, and upload it 2 hours after receiving it.

 8. You must submit the exam (by uploading to TigerFile) within
    2 hours of the time you received it, with a five minute (extra)
    grace period.

 9. You MAY call upon functions from the OCaml standard library.
*)

exception Unimplemented  ;;

(* ------------------ PROBLEM 0 ---------------------------------------- *)

(* The following OCaml expression, if you uncomment it here,
  will cause the OCaml compiler to give an error message:

  a+b+c ;;

  On the other hand, suppose we write, *)

let a = 1
let b = 2
let c = 3 ;;

 (* and now we write the same OCaml expression: *)

  a+b+c ;;

(* Then the OCaml compiler evaluates this to 6.  Explain why one works and
  the other does not, using the word "environment" in your answer.

 YOUR ANSWER HERE:




 --------------------- PROBLEM 1 --------------------------

   A subset of OCaml expressions can be represented using these
   datatypes.  The meaning of these operators is exactly as in Assignment 4
   (substitution-based interpreter). *)

type variable = string

let var_eq (x: variable) (y: variable) = (String.compare x y = 0)
let var_neq (x:variable) (y: variable) = not (String.compare x y = 0)

type constant = Int of int | Bool of bool
type operator = Plus | Minus | Times | Div | Less | LessEq

type exp =
  (* Basic *)
  | Var of variable
  | Constant of constant
  | Op of exp * operator * exp
  (* If (conditional, consequent, alternative) *)
  | If of exp * exp * exp
  (* Let (v, e1, e2) is a let binding with the form let v = e1 in e2 *)
  | Let of variable * exp * exp
  (* Rec (f, x, b) is the definition of a possibly-recursive function
     The function is named f and x is the name of the parameter. b is
     the body of the expression, and may contain f and/or x. *)
  | Rec of variable * variable * exp
  (* App (f, x) is a function call of closure f with argument x *)
  | App of exp * exp

(* Here are some sample expressions *)
let v0 = (let x=1 in let x'=2 in x+x')
let v0' = (let x'=1 in let x''=2 in x'+x'')

(* Here is the representation of v0 in our "exp" syntax: *)
let e0 = Let("x",Constant(Int 1),Let("x'",Constant(Int 2),
              Op(Var"x",Plus,Var"x'")))

let v1 = let rec fac x = if x<1 then 1 else x * fac(x-1) in fac
let e1 = Rec("fac","x",
             If(Op(Var "x",Less,Constant(Int 1)),
		Constant(Int 1),
		Op(Var "x",Times,
		   App(Var"fac",Op(Var"x",Minus,Constant(Int 1))))))

let v2 = let v0' = 5 in v0+v0'
let e2 = Let("v0'",Constant(Int 5),
		 Op(Var"v0",Plus,Var"v0'"))

(* PROBLEM 1.  Renaming of bound variables.

  As you know, the OCaml function  (fun x -> x+y)
  should behave exactly the same as (fun x' -> x'+y)
  even if embedded in a larger expression that uses x or x' or y.
  That is,
 *)
let v9 =    (let x = 1 in let y = 2 in let x' = 3 in (fun x -> x+y) 4)  ;;
    (*  behaves exactly the same as *)
let v10 =   (let x = 1 in let y = 2 in let x' = 3 in (fun x' -> x'+y) 4) ;;

(* PROBLEM 1.1

 This function appends an apostrophe to the end of a variable name. *)

let prime (x: variable) : variable = x ^ "'"

(* Write a function prime_exp that appends a prime to EVERY variable
  within an expression, at every place that it occurs.

YOUR ANSWER HERE: *)
let prime_exp (e: exp) : exp = raise Unimplemented

(* You can try it out on the expressions e0, e1, e2, defined above. *)

(* PROBLEM 1.2.a.
  Write an expression in OCaml that does NOT behave the same
  (in some environments) if you simply add a prime to every variable.

YOUR ANSWER HERE:


  PROBLEM 1.2.b.
  Represent your OCaml expression in the abstract syntax constructors:

YOUR ANSWER HERE: *)

let answer_1_2_b : exp =
  Constant (Int 0)  (* Replace this line with the right answer! *)

(* Don't edit the lines below, but you can try it out on your answer_1_2_b. *)
let primed_answer_1_2_b =
    try prime_exp answer_1_2_b
    with Unimplemented -> Constant (Int 1)

(* PROBLEM 1.3:  Write a safe prime_exp function.

 Write a function that renames (adds a prime to the name of) every bound
 variable, and renames all the occurrences of those bound variables within
 their scopes, but leaves the free variables of an expression alone.

 If, in the process, a free variable falls within the scope of a
 just-renamed bound variable, raise the exception Capture.

 Examples:
  let x = y+1 in x+x+y  ->  let x' = y+1 in x'+x'+y
  let x = x+1 in x+x+y  ->  let x' = x+1 in x'+x'+y
  let x = y+1 in let z=x+x in z+y -> let x' = y+1 in let z'=x'+x' in z'+y
  let x = y+1 in let x=x+x in x+y -> let x' = y+1 in let x'=x'+x' in x'+y
  let x = 5 in x' ->  raise Capture
  let x = 5 in x'+x ->  raise Capture

 If you don't implement the Capture-detection part, but everything else
 is right, you will still get substantial partial credit.

 YOUR ANSWER HERE: *)
exception Capture ;;

let safe_prime_exp (e: exp) : exp = raise Unimplemented


(* -------------------------- PROBLEM 2 ---------------------------------

 Consider representing polynomials as a list of their coefficients.
 In general, a list [c0; c1; ...; cn] represents the following polynomial:

 c0*x^0 + c1*x^1 + ... + cn*x^n

For instance, the list [3.0; 0.0; 7.0; 5.0] represents the polynomial:

  3*x^0 + 7*x^2 + 5*x^3

Below we define a type for polynomials and a couple of functions to
evaluate a polynomial p at a given point x.
*)

type poly = float list

(*
let pow (x: float) (k: int) =
  if k>=0 then Float.pow x (Float.of_int k)
  else 0.0
  *)

(* Your proofs must be structured as shown in class.  Each proof
  step must come with a justification.  If you do not know how
  to justify a proof step, say "I don't know".  Saying "I don't know"
  is preferred to making up a phony, incorrect justification.

  You may use these facts about exponentiation in your proofs
    (refer to these fact using the names "E1", "E2", etc):

   (E1) for all k:nat, k > 0 implies pow 0.0 k = 0.0
   (E2) for all x:float, pow x 0 = 1.0
   (E3) for all x:float, pow x 1 = x
   (E4) for all x:float, for all k:nat,   x *. pow x k = pow x (k + 1)

  Ignore floating-point inaccuracies, such as rounding error,
  and pretend that we're doing exact operations on the real numbers.

  Although in mathematics 0^0 is undefined, it so happens that
    pow 0.0 0 = 1.0   in OCaml.

  You may use basic facts about simple, standard mathematical operations
  like +, +., *, *., etc. -- justify such proof steps by saying "by math".

  If you use induction in your proofs,  clearly state the IH.
*)

(* evaluate a polynomial p at point x and multiply by x^n *)
(*
let rec evaln (n:int) (p:poly) (x:float) =
  match p with
  | [] -> 0.0
  | cn::rest -> (cn *. pow x n) +. evaln (n+1) rest x
  *)

(* evaluate a polynomial p at point x *)
(*
let eval p x = evaln 0 p x
*)

(* One can implement a variety of operations over such a representation of
  polynomials (as you may have done in assignment #3).  For instance, here
  is an operation to scale polynomial p by a constant factor a. *)

let rec scale (a: float) (p: poly) : poly =
  match p with
  | [] -> []
  | c::rest -> (a*.c) :: scale a rest

(* PROBLEM 2.1:  Prove this about scaling:

   for all a:float, for all b:float, for all p:poly,
     scale a (scale b p) = scale b (scale a p)

  Proof:
  YOUR ANSWER HERE



  PROBLEM 2.2:
  In this representation there are multiple different representations
  of the same polynomial.  For example, there are multiple representations
  of 0.  Indeed, there are infinitely many!  For all k, there is a list of
  length k that represents 0. *)

let rec zero (k:int) : poly =
  if k <= 0 then []
  else 0.0::zero (k-1)

(* PROBLEM 2.2  Prove the following theorem.  You are allowed
   to prove some supporting lemmas if needed.

   for all x:float. for all k:nat, eval (zero k) x == 0.0

  Proof:
  YOUR ANSWER HERE


  ------------------------------ Epilog ---------------------------

   There were six places labeled YOUR ANSWER HERE, check that you
   didn't miss one.

   Sign the standard statement by typing your name in the blank:
   This paper represents my own work in accordance with University regulations.

  ______________________________
*)
